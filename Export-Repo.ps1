# Code Generated by Sidekick is for learning and experimentation purposes only.
param(
  [string]$Root = (Get-Location).Path,
  [string]$OutDir = (Join-Path (Get-Location).Path "_sidekick_export"),
  [int]$MaxCharsPerFile = 200000
)

$ErrorActionPreference = "Stop"

# Folders to skip
$ExcludeDirNames = @(".git",".vs","bin","obj","node_modules",".idea",".vscode","TestResults","packages")

# Files to skip (common secret/binary artifacts)
$ExcludeFilePatterns = @(
  "*.dll","*.exe","*.pdb","*.cache","*.zip","*.7z","*.png","*.jpg","*.jpeg","*.gif","*.ico",
  "*.pdf","*.pfx","*.snk","*.cer","*.key","*.db","*.sqlite","*.nupkg",
  ".env","*.env","secrets.json","appsettings.*.json"
)

# Only include these extensions as "text-like" (add more if needed)
$IncludeExt = @(
  ".sln",".csproj",".props",".targets",".cs",".csx",".razor",".cshtml",
  ".json",".yml",".yaml",".xml",".config",".ini",".editorconfig",
  ".md",".txt",".gitignore",".gitattributes",
  ".sql",".http",".rest",
  ".js",".ts",".jsx",".tsx",".css",".scss",".html",
  ".ps1",".sh",".bat"
)

function New-Dir([string]$Path) {
  if (-not (Test-Path $Path)) { New-Item -ItemType Directory -Path $Path | Out-Null }
}

function Is-ExcludedDir([string]$FullPath) {
  foreach ($name in $ExcludeDirNames) {
    if ($FullPath -match [regex]::Escape([IO.Path]::DirectorySeparatorChar + $name + [IO.Path]::DirectorySeparatorChar) -or
        $FullPath.EndsWith([IO.Path]::DirectorySeparatorChar + $name)) {
      return $true
    }
  }
  return $false
}

function Matches-AnyPattern([string]$Name, [string[]]$Patterns) {
  foreach ($p in $Patterns) { if ($Name -like $p) { return $true } }
  return $false
}

function Get-RelativePathSafe([string]$Base, [string]$Path) {
  $baseUri = [Uri]((Resolve-Path $Base).Path.TrimEnd('\','/') + [IO.Path]::DirectorySeparatorChar)
  $pathUri = [Uri](Resolve-Path $Path).Path
  return [Uri]::UnescapeDataString($baseUri.MakeRelativeUri($pathUri).ToString().Replace('/',[IO.Path]::DirectorySeparatorChar))
}

function Get-TreeLines([string]$StartPath) {
  $lines = New-Object System.Collections.Generic.List[string]
  $lines.Add(".")
  $items = Get-ChildItem -LiteralPath $StartPath -Force | Sort-Object { $_.PSIsContainer } , Name
  for ($i=0; $i -lt $items.Count; $i++) {
    $isLast = ($i -eq $items.Count-1)
    $prefix = if ($isLast) { "└── " } else { "├── " }
    $lines.Add($prefix + $items[$i].Name)
    if ($items[$i].PSIsContainer -and -not (Is-ExcludedDir $items[$i].FullName)) {
     $childLines = Get-TreeLinesInternal $items[$i].FullName $(if ($isLast) { "    " } else { "│   " })
      foreach ($cl in $childLines) { $lines.Add($cl) }
    }
  }
  return $lines
}

function Get-TreeLinesInternal([string]$Path, [string]$Indent) {
  $lines = New-Object System.Collections.Generic.List[string]
  $items = Get-ChildItem -LiteralPath $Path -Force | Sort-Object { $_.PSIsContainer } , Name
  for ($i=0; $i -lt $items.Count; $i++) {
    $isLast = ($i -eq $items.Count-1)
    $prefix = if ($isLast) { "└── " } else { "├── " }
    $lines.Add($Indent + $prefix + $items[$i].Name)
    if ($items[$i].PSIsContainer -and -not (Is-ExcludedDir $items[$i].FullName)) {
      $nextIndent = $Indent + $(if ($isLast) { "    " } else { "│   " })
      $childLines = Get-TreeLinesInternal $items[$i].FullName $nextIndent
      foreach ($cl in $childLines) { $lines.Add($cl) }
    }
  }
  return $lines
}

# Prepare output
New-Dir $OutDir
New-Dir (Join-Path $OutDir "files")

$structurePath = Join-Path $OutDir "structure.txt"
$allPath       = Join-Path $OutDir "all_files.txt"

# Write folder tree
$tree = Get-TreeLines $Root
$tree -join [Environment]::NewLine | Set-Content -LiteralPath $structurePath -Encoding UTF8

# Export files
$exported = 0
$skipped = 0

Get-ChildItem -LiteralPath $Root -Recurse -Force -File | ForEach-Object {
  $full = $_.FullName
  if (Is-ExcludedDir $full) { $skipped++; return }

  if (Matches-AnyPattern $_.Name $ExcludeFilePatterns) { $skipped++; return }

  $ext = $_.Extension.ToLowerInvariant()
  if (($IncludeExt -notcontains $ext) -and ($_.Name -notin @("Dockerfile","Makefile"))) { $skipped++; return }

  $rel = Get-RelativePathSafe $Root $full

  # Read as text safely (skip if binary-ish)
  $bytes = [IO.File]::ReadAllBytes($full)
  if ($bytes -contains 0) { $skipped++; return } # crude binary check

  $text = [Text.Encoding]::UTF8.GetString($bytes)
  if ($text.Length -gt $MaxCharsPerFile) {
    $text = $text.Substring(0, $MaxCharsPerFile) + "`r`n... (truncated) ..."
  }

  # Per-file txt (mirrors structure)
  $target = Join-Path (Join-Path $OutDir "files") ($rel + ".txt")
  New-Dir ([IO.Path]::GetDirectoryName($target))
  $text | Set-Content -LiteralPath $target -Encoding UTF8

  # Combined file (best one to upload)
  $header = "===== FILE: $rel ====="
  Add-Content -LiteralPath $allPath -Encoding UTF8 -Value $header
  Add-Content -LiteralPath $allPath -Encoding UTF8 -Value $text
  Add-Content -LiteralPath $allPath -Encoding UTF8 -Value "`r`n"

  $exported++
}

"Export complete."
"Root: $Root"
"OutDir: $OutDir"
"Exported files: $exported"
"Skipped files: $skipped"
"Upload this file: $allPath"
